document.addEventListener("DOMContentLoaded", function () {
    // Í∏∞Ï°¥ Ï¥àÍ∏∞Ìôî ÏΩîÎìúÎì§ Ïã§Ìñâ
    initializeVehicles(); // Ï∞®Îüâ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
    updateDashboard(); // ÎåÄÏãúÎ≥¥Îìú Ï¥àÍ∏∞ ÏóÖÎç∞Ïù¥Ìä∏

    updateSectionValues(); // ‚úÖ ÌéòÏù¥ÏßÄ Î°úÎìú ÌõÑ Ï¶âÏãú Ïã§Ìñâ (Ï¥àÍ∏∞ÌôîÎêú Îç∞Ïù¥ÌÑ∞ Î∞òÏòÅ)
    setInterval(updateSectionValues, 100); // ‚úÖ 10Ï¥àÎßàÎã§ Ïã§Ìñâ (ÏóÖÎç∞Ïù¥Ìä∏ Ïú†ÏßÄ)
});

document.addEventListener("DOMContentLoaded", function () {
    function updateDateTime() {
        const dateTimeElement = document.getElementById("current-datetime");
        if (!dateTimeElement) return; // ÏöîÏÜåÍ∞Ä ÏóÜÏúºÎ©¥ Ïã§ÌñâÌïòÏßÄ ÏïäÏùå
        
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, "0");
        const day = String(now.getDate()).padStart(2, "0");
        const hours = String(now.getHours()).padStart(2, "0");
        const minutes = String(now.getMinutes()).padStart(2, "0");
        const seconds = String(now.getSeconds()).padStart(2, "0");

        // yyyy/MM/dd HH:mm:ss ÌòïÏãùÏúºÎ°ú ÎÇ†Ïßú Î∞è ÏãúÍ∞Ñ ÌëúÏãú
        const formattedDateTime = `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;

        // HTML ÏöîÏÜå ÏóÖÎç∞Ïù¥Ìä∏
        dateTimeElement.innerText = formattedDateTime;
    }

    // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï¶âÏãú Ïã§Ìñâ Î∞è Îß§Ï¥àÎßàÎã§ ÏóÖÎç∞Ïù¥Ìä∏
    updateDateTime();
    setInterval(updateDateTime, 1000);
});


document.addEventListener('DOMContentLoaded', function () {

    const languageSelector = document.getElementById("language-selector");

    // üîπ Ïñ∏Ïñ¥ ÏÑ†ÌÉù Î≤ÑÌäº ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä (KO ‚Üî ENG Ï†ÑÌôò)
    languageSelector.addEventListener("click", function () {
        if (languageSelector.textContent.trim() === "KO") {
            languageSelector.textContent = "ENG";
        } else {
            languageSelector.textContent = "KO";
        }
        languageSelector.classList.toggle("active"); // ÏãúÍ∞ÅÏ†ÅÏù∏ Î≥ÄÌôî (ÌïÑÏöîÌïòÎ©¥ ÏÇ¨Ïö©)
    });
    
    const mapContainer = document.getElementById('map');
    const mapOption = {
        center: new kakao.maps.LatLng(37.5665, 126.9780),
        level: 7
    }; 
    const map = new kakao.maps.Map(mapContainer, mapOption);
    
    const toggleButton = document.getElementById('toggle-button');
    const D = document.getElementById('side-dashboard');
    const closeDashboardBtn = document.getElementById('close-dashboard');
    const logOutBtn = document.getElementById('log-out-btn'); // LOG-OUT Î≤ÑÌäº ÏÑ†ÌÉù

    toggleButton.addEventListener('click', () => {
        if (sideDashboard.classList.contains('open')) {
            sideDashboard.classList.remove('open');
        } else {
            sideDashboard.classList.add('open');
        }
    });           
    
    // LOG-OUT Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
    logOutBtn.addEventListener('click', () => {
        window.location.href = 'index.html'; // index.htmlÎ°ú Ïù¥Îèô
    });

    // Î©îÎâ¥ ÎìúÎ°≠Îã§Ïö¥ ÌÜ†Í∏Ä Í∏∞Îä• Ï∂îÍ∞Ä
    const menuHeaders = document.querySelectorAll('.menu-header');

    menuHeaders.forEach(header => {
        header.addEventListener('click', () => {
            const subMenu = header.nextElementSibling;

            if (subMenu && subMenu.classList.contains('sub-menu')) {
                const isOpen = subMenu.style.display === 'block';
                subMenu.style.display = isOpen ? 'none' : 'block'; // ÌÜ†Í∏Ä
                header.classList.toggle('active'); // ÏïÑÏù¥ÏΩò ÌöåÏ†Ñ
            }
        });
    });

    const imageSrc = 'car.png';
    const imageSize = new kakao.maps.Size(40, 40);
    const markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize);

    const regions = [
        { name: 'Seoul', lat: 37.4484, lng: 127.0588 },
        { name: 'hwasung', lat: 37.1994, lng: 126.8311 },
        { name: 'Jeju', lat: 33.4996, lng: 126.5312 },
        { name: 'Ulsan', lat: 35.5384, lng: 129.3114 }
    ];

    const roadSpeeds = {
        general: 60, // ÏùºÎ∞òÎèÑÎ°ú (km/h)
        national: 80, // Íµ≠ÎèÑ (km/h)
        highway: 100 // Í≥†ÏÜçÎèÑÎ°ú (km/h)
    };    
    
    function calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLng = (lng2 - lng1) * Math.PI / 180;
        const a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLng / 2) * Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c; // km Îã®ÏúÑ Í±∞Î¶¨ Î∞òÌôò
    }

    async function fetchRoadPath(startLat, startLng, endLat, endLng) {
        const url = `https://apis-navi.kakaomobility.com/v1/route?origin=${startLng},${startLat}&destination=${endLng},${endLat}&priority=RECOMMEND`;
        const headers = {
            Authorization: "KakaoAK 3ee7f1efcef64edd9dd238f6aea79835"
        };
    
        try {
            const response = await fetch(url, { headers });
            const data = await response.json();
    
            if (data.routes && data.routes.length > 0) {
                const roadPath = [];
                const sections = data.routes[0].sections;
    
                sections.forEach((section) => {
                    section.roads.forEach((road) => {
                        const vertexes = road.vertexes;
                        for (let i = 0; i < vertexes.length; i += 2) {
                            roadPath.push({ lat: vertexes[i], lng: vertexes[i + 1] });
                        }
                    });
                });
    
                return roadPath;
            } else {
                console.warn("No road path found.");
                return [];
            }
        } catch (error) {
            console.error("Error fetching road path:", error);
            return [];
        }
    }
    
    // Ï∞®Îüâ ÏÉùÏÑ± Ïãú ÎèÑÎ°ú ÏúÑ Í≤ΩÎ°ú ÏÉùÏÑ±
    async function createVehicle(id, region) {
        let roadPath = [];
        do {
            const destinationLat = region.lat + Math.random() * 0.05 - 0.025;
            const destinationLng = region.lng + Math.random() * 0.05 - 0.025;
            roadPath = await fetchRoadPath(region.lat, region.lng, destinationLat, destinationLng);
        } while (roadPath.length === 0); // ÏàòÏ†ï: ÎπÑÎèÑÎ°ú Í≤ΩÎ°ú Î∞©ÏßÄ

        return {
            id,
            marker: new kakao.maps.Marker({
                position: new kakao.maps.LatLng(region.lat, region.lng),
                image: markerImage,
                map: map
            }),
            path: roadPath,
            index: 0
        };
    }

// Ï∞®ÎüâÏù¥ ÎèÑÎ°ú ÎÅùÏóê ÎèÑÎã¨ÌïòÎ©¥ ÏÉàÎ°úÏö¥ Í≤ΩÎ°ú ÏÉùÏÑ±
async function moveVehicles() {
    for (const vehicle of vehicles) {
        if (vehicle.index >= vehicle.path.length - 1) {
            const currentPos = vehicle.marker.getPosition();
            const newDestinationLat = currentPos.getLat() + Math.random() * 0.05 - 0.025;
            const newDestinationLng = currentPos.getLng() + Math.random() * 0.05 - 0.025;

            // ‚úÖ 'await'ÏùÑ ÏÇ¨Ïö©ÌïòÎ†§Î©¥ moveVehicles()ÎèÑ asyncÎ°ú Î≥ÄÍ≤ΩÌï¥Ïïº Ìï®
            vehicle.path = await fetchRoadPath(currentPos.getLat(), currentPos.getLng(), newDestinationLat, newDestinationLng);
            vehicle.index = 0;
        }

        const nextPos = vehicle.path[vehicle.index];
        if (!nextPos) continue;

        const nextLatLng = new kakao.maps.LatLng(nextPos.lat, nextPos.lng);

        animateVehicleMove(vehicle, nextLatLng, () => {
            vehicle.index++;
            vehicle.status = ['Drive', 'Stop', 'Ready'][Math.floor(Math.random() * 3)];
            vehicle.safety = ['Best', 'Good', 'Caution'][Math.floor(Math.random() * 3)];
            vehicle.device = ['On', 'Check', 'Off'][Math.floor(Math.random() * 3)];

            updateDashboard();  // ‚úÖ Ïù¥Îèô ÌõÑ ÎåÄÏãúÎ≥¥Îìú Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
        });
    }
}

// ‚úÖ Í∏∞Ï°¥ setIntervalÏùÑ Ïú†ÏßÄÌïòÏó¨ Ï∞®Îüâ Ïù¥ÎèôÏù¥ Î∞òÎ≥µ Ïã§ÌñâÎêòÎèÑÎ°ù Ìï®
setInterval(moveVehicles, 5000);


    async function initializeVehicles() {
        const vehicleCounts = {
            Seoul: 20,
            Gyeonggi: 15,
            Jeju: 5,
            Ulsan: 8,
        };

        vehicles = [
            ...(await Promise.all(
                Array.from({ length: vehicleCounts.Seoul }, (_, i) =>
                    createVehicle(i + 1, regions[0])
                )
            )),
            ...(await Promise.all(
                Array.from({ length: vehicleCounts.Gyeonggi }, (_, i) =>
                    createVehicle(i + 1 + vehicleCounts.Seoul, regions[1])
                )
            )),
            ...(await Promise.all(
                Array.from({ length: vehicleCounts.Jeju }, (_, i) =>
                    createVehicle(
                        i + 1 + vehicleCounts.Seoul + vehicleCounts.Gyeonggi,
                        regions[2]
                    )
                )
            )),
            ...(await Promise.all(
                Array.from({ length: vehicleCounts.Ulsan }, (_, i) =>
                    createVehicle(
                        i +
                        1 +
                        vehicleCounts.Seoul +
                        vehicleCounts.Gyeonggi +
                        vehicleCounts.Jeju,
                        regions[3]
                    )
                )
            )),
        ];
    }         

    function createVehicle(id, region) {
        // ÎèÑÎ°ú ÏúÑÏùò Í≤ΩÎ°úÎ•º ÏÉùÏÑ±
        function generateRoadPath(region) {
            const roadPath = [
                { lat: region.lat, lng: region.lng },
                { lat: region.lat + 0.005, lng: region.lng + 0.005 },
                { lat: region.lat - 0.005, lng: region.lng + 0.005 },
                { lat: region.lat + 0.005, lng: region.lng - 0.005 },
                { lat: region.lat - 0.005, lng: region.lng - 0.005 }
            ];
        
            return Array.from({ length: 5 }, () => ({
                lat: region.lat + Math.random() * 0.1 - 0.05, // Î∞òÍ≤Ω 0.02 (ÌôïÎåÄÎêú Î≤îÏúÑ)
                lng: region.lng + Math.random() * 0.1 - 0.05,
                roadType: ['general', 'national', 'highway'][Math.floor(Math.random() * 3)]
            }));
        }
        
    
        return {
            id,
            marker: new kakao.maps.Marker({
                position: new kakao.maps.LatLng(region.lat, region.lng), // ÏßÄÏó≠ Ï§ëÏã¨ÏúºÎ°ú Ï¥àÍ∏∞ ÏúÑÏπò Í≥†Ï†ï
                image: markerImage,
                map: map
            }),
            
            path: generateRoadPath(region), // ÎèÑÎ°ú ÏúÑ Í≤ΩÎ°ú ÏÉùÏÑ±
            status: ['Drive', 'Stop', 'Ready'][Math.floor(Math.random() * 3)],
            safety: ['Best', 'Good', 'Caution'][Math.floor(Math.random() * 3)],
            device: ['On', 'Check', 'Off'][Math.floor(Math.random() * 3)],
            index: 0
        };
    }

    let vehicles = initializeVehicles();

    function moveVehicles() {
        vehicles.forEach(vehicle => {
            if (vehicle.index >= vehicle.path.length - 1) {
                vehicle.index = 0; // Í≤ΩÎ°ú ÏàúÌôò
            }
    
            const currentPos = vehicle.marker.getPosition();
            const nextPos = vehicle.path[vehicle.index];
            const nextLatLng = new kakao.maps.LatLng(nextPos.lat, nextPos.lng);
    
            const distance = calculateDistance(
                currentPos.getLat(),
                currentPos.getLng(),
                nextPos.lat,
                nextPos.lng
            );          

            const speed = roadSpeeds[nextPos.roadType]; // ÎèÑÎ°ú Ïú†ÌòïÏóê Îî∞Î•∏ ÏÜçÎèÑ
            const travelTime = (distance / speed) * 3600; // Ïù¥Îèô ÏãúÍ∞Ñ (Ï¥à)
            const frames = travelTime * 60; // 60fps Í∏∞Ï§Ä ÌîÑÎ†àÏûÑ Ïàò
            let frame = 0;
    
            function animate() {
                frame++;
                const progress = frame / frames;
            
                const interpolatedLat =
                    currentPos.getLat() + (nextPos.lat - currentPos.getLat()) * progress;
                const interpolatedLng =
                    currentPos.getLng() + (nextPos.lng - currentPos.getLng()) * progress;
            
                const interpolatedPos = new kakao.maps.LatLng(interpolatedLat, interpolatedLng);
                vehicle.marker.setPosition(interpolatedPos);
            
                if (frame < frames) {
                    requestAnimationFrame(animate);
                } else {
                    vehicle.index++;
                    vehicle.vehicle = ['Drive', 'Stop', 'Ready'][Math.floor(Math.random() * 3)];
                    vehicle.safety = ['Best', 'Good', 'Caution'][Math.floor(Math.random() * 3)];
                    vehicle.device = ['on', 'check', 'off'][Math.floor(Math.random() * 3)];
            
                    updateDashboard(); // Îß§ Ïù¥Îèô ÌõÑ ÎåÄÏãúÎ≥¥Îìú ÏóÖÎç∞Ïù¥Ìä∏
                }
            }           
    
            animate();
        });
    }
    function animateNumberChange(element, start, end, duration = 15000) {
        if (start === end) {
            element.innerText = end; // Í∞íÏù¥ Í∞ôÏúºÎ©¥ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©ÌïòÏßÄ ÏïäÏùå
            return;
        }

        const frameRate = 10000; // ÌîÑÎ†àÏûÑ ÏÜçÎèÑÎ•º Ï§ÑÏûÑ (Ï¥àÎãπ 30 ÌîÑÎ†àÏûÑ)
        const totalFrames = (duration / 10000) * frameRate;
        let currentFrame = 0;

        const easeInOutQuad = (t) => {
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        };

        function updateNumber() {
            currentFrame++;
            const progress = easeInOutQuad(currentFrame / totalFrames);
            const newValue = Math.round(start + (end - start) * progress);
    
            element.innerText = newValue; // ÌôîÎ©¥ ÏóÖÎç∞Ïù¥Ìä∏
    
            if (currentFrame < totalFrames) {
                setTimeout(updateNumber, 10000 / frameRate); // ÌîÑÎ†àÏûÑ ÏÜçÎèÑ Ï°∞Ï†à (Îçî Ï≤úÏ≤úÌûà Î≥ÄÌï®)
            } else {
                element.innerText = end; // ÏµúÏ¢ÖÍ∞í Î≥¥Ï†ï
            }
        }

        // Î∂ÄÎìúÎü¨Ïö¥ Ìà¨Î™ÖÎèÑ Î∞è ÌÅ¨Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï∂îÍ∞Ä
        element.style.transition = 'opacity 1.5s ease-in-out, transform 1.5s ease-in-out';
        element.style.opacity = 0.5;
        setTimeout(() => {
            element.style.opacity = 1;
            element.style.transform = 'scale(1)';
            setTimeout(() => {
                element.style.transform = 'scale(1)';
            }, 7000);
        }, 2000);

        updateNumber();
}

    function updateAllNumbers(driveCount, stopCount, readyCount) {
        animateNumberChange(
            document.getElementById("drive-count"),
            parseInt(document.getElementById("drive-count").innerText),
            driveCount
        );
    
        animateNumberChange(
            document.getElementById("stop-count"),
            parseInt(document.getElementById("stop-count").innerText),
            stopCount
        );
    
        animateNumberChange(
            document.getElementById("ready-count"),
            parseInt(document.getElementById("ready-count").innerText),
            readyCount
        );

        animateNumberChange(
            document.getElementById("safety-best"),
            parseInt(document.getElementById("safety-best").innerText),
            driveCount
        );
    
        animateNumberChange(
            document.getElementById("safety-good"),
            parseInt(document.getElementById("safety-good").innerText),
            stopCount
        );
    
        animateNumberChange(
            document.getElementById("safety-caution"),
            parseInt(document.getElementById("safety-caution").innerText),
            readyCount
        );        
    }      
        setInterval(() => {
            updateAllNumbers(
                Math.floor(Math.random() * 100), 
                Math.floor(Math.random() * 100), 
                Math.floor(Math.random() * 100),
                Math.floor(Math.random() * 100),
                Math.floor(Math.random() * 100),
                Math.floor(Math.random() * 100),
                Math.floor(Math.random() * 100),
                Math.floor(Math.random() * 100),
                Math.floor(Math.random() * 100),
            );
        }, 5000);
    
    function animateNumberChange(element, start, end, duration = 0.005) {
        const stepTime = 10; // ÏóÖÎç∞Ïù¥Ìä∏ Í∞ÑÍ≤© (Î∞ÄÎ¶¨Ï¥à)
        const steps = Math.floor(duration / stepTime); // Ï¥ù Ïä§ÌÖù Ïàò
        const increment = (end - start) / steps; // Îã®Í≥ÑÎ≥Ñ Ï¶ùÍ∞ÄÎüâ
        let current = start; // ÌòÑÏû¨ Í∞í Ï¥àÍ∏∞Ìôî
        let step = 0;
    
        function stepAnimation() {
            current += increment; // Í∞í Ï¶ùÍ∞Ä
            element.innerText = (Math.round(current * 10) / 10).toFixed(1); // ÏÜåÏàòÏ†ê Ï≤´Ïß∏ ÏûêÎ¶¨ÍπåÏßÄ ÌëúÌòÑ
            step++;
    
            if (step < steps) {
                setTimeout(stepAnimation, stepTime); // Îã§Ïùå Ïä§ÌÖùÏúºÎ°ú ÏßÑÌñâ
            } else {
                element.innerText = end.toFixed(1); // ÎßàÏßÄÎßâ Í∞í Î≥¥Ï†ï
            }
        }
    
        stepAnimation(); // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
    }   

    setInterval(moveVehicles, 5000);

    function updateNumberSmoothly(element, newValue) {
        const currentValue = parseInt(element.innerText);
        if (currentValue !== newValue) {
            element.innerText = newValue;
        }
    }
    
    function animateValueChange(element, newValue) {
        const oldValue = parseInt(element.innerText) || 0;
        if (oldValue === newValue) return; // Í∞íÏù¥ ÎèôÏùºÌïòÎ©¥ Ïï†ÎãàÎ©îÏù¥ÏÖò Ïã§Ìñâ X
    
        // Í∏∞Ï°¥ Í∞íÏù¥ ÏúÑÎ°ú ÏÇ¨ÎùºÏßÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©
        element.style.transform = "translateY(-20px)";
        element.style.opacity = "0";
        
        setTimeout(() => {
            element.innerText = newValue; // ÏÉàÎ°úÏö¥ Í∞í Ï†ÅÏö©
            element.style.transform = "translateY(10px)"; // ÏÉàÎ°úÏö¥ Í∞í ÏïÑÎûòÏóêÏÑú ÏãúÏûë
            element.style.opacity = "0"; 
    
            setTimeout(() => {
                element.style.transform = "translateY(0)"; // ÏõêÎûò ÏúÑÏπòÎ°ú Î≥µÍ∑Ä
                element.style.opacity = "1";
            }, 500);
        }, 500); // Í∏∞Ï°¥ Í∞íÏù¥ ÏÇ¨ÎùºÏßÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÍ∞ÑÍ≥º ÎßûÏ∂§
    }

    function updateDashboard() {
        const driveCount = vehicles.filter(v => v.status === 'Drive').length;
        const stopCount = vehicles.filter(v => v.status === 'Stop').length;
        const readyCount = vehicles.filter(v => v.status === 'Ready').length;
    
        const safetyBest = vehicles.filter(v => v.safety === 'Best').length;
        const safetyGood = vehicles.filter(v => v.safety === 'Good').length;
        const safetyCaution = vehicles.filter(v => v.safety === 'Caution').length;
    
        const deviceOn = vehicles.filter(v => v.device === 'On').length;
        const deviceCheck = vehicles.filter(v => v.device === 'Check').length;
        const deviceOff = vehicles.filter(v => v.device === 'Off').length;
    
        // ‚úÖ ÏßÄÏó≠Î≥Ñ Ï∞®Îüâ Í∞úÏàò Í≥ÑÏÇ∞
        const regionCounts = {
            Seoul: vehicles.filter(v => calculateDistance(
                v.marker.getPosition().getLat(), 
                v.marker.getPosition().getLng(), 
                regions[0].lat, 
                regions[0].lng
            ) < 50).length, // Î∞òÍ≤ΩÏùÑ 30kmÎ°ú ÌôïÏû•
            Gyeonggi: vehicles.filter(v => calculateDistance(
                v.marker.getPosition().getLat(), 
                v.marker.getPosition().getLng(), 
                regions[1].lat, 
                regions[1].lng
            ) < 50).length,
            Jeju: vehicles.filter(v => calculateDistance(
                v.marker.getPosition().getLat(), 
                v.marker.getPosition().getLng(), 
                regions[2].lat, 
                regions[2].lng
            ) < 50).length,
            Ulsan: vehicles.filter(v => calculateDistance(
                v.marker.getPosition().getLat(), 
                v.marker.getPosition().getLng(), 
                regions[3].lat, 
                regions[3].lng
            ) < 50).length
        };

         // ‚úÖ VEHICLE ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    animateValueChange(document.getElementById("drive-count"), driveCount);
    animateValueChange(document.getElementById("stop-count"), stopCount);
    animateValueChange(document.getElementById("ready-count"), readyCount);

    animateValueChange(document.getElementById("safety-best"), safetyBest);
    animateValueChange(document.getElementById("safety-good"), safetyGood);
    animateValueChange(document.getElementById("safety-caution"), safetyCaution);

    animateValueChange(document.getElementById("device-on"), deviceOn);
    animateValueChange(document.getElementById("device-check"), deviceCheck);
    animateValueChange(document.getElementById("device-off"), deviceOff);

// ÎåÄÏãúÎ≥¥Îìú Ï£ºÍ∏∞Ï†Å ÏóÖÎç∞Ïù¥Ìä∏
setInterval(updateDashboard, 5000);

// **Ï∂îÍ∞ÄÎêú Ìï®Ïàò**
const dashboardSections = document.querySelectorAll('.section');

function updateSectionValues() {
    dashboardSections.forEach(section => {
        const titleText = section.querySelector('.title').innerText;

        const infoItems = section.querySelectorAll('.info-item span:last-child');
        const valueElement = section.querySelector('.value');

        let greenCount = 0;
        infoItems.forEach(item => {
            const color = window.getComputedStyle(item.previousElementSibling).color;
            if (color === 'rgb(0, 128, 0)') {
                greenCount += parseInt(item.textContent, 10);
            }
        });

        const totalCount = Array.from(infoItems).reduce((sum, item) => sum + parseInt(item.textContent, 10), 0);

        if (titleText.includes("AREA")) {
            // ‚úÖ AREA Í∞íÏù¥ 0Ïù¥Î©¥ 42Î°ú Î≥µÍµ¨
            if (parseInt(valueElement.textContent) === 0) {
                valueElement.textContent = '42';
            }
            return;
        }

        if (totalCount > 0) {
            valueElement.textContent = `${Math.round((greenCount / totalCount) * 100)}`;
        } else {
            valueElement.textContent = '20';
        }
    });
}

setInterval(() => {
    updateDashboard();
    updateSectionValues();
}, 5000);  

function updateTextElement(id, newValue) {
    const element = document.getElementById(id);
    if (parseInt(element.innerText) !== newValue) {
        element.innerText = newValue;
    }
}

function updateDashboard() {
    updateTextElement('drive-count', driveCount);
    updateTextElement('stop-count', stopCount);
    updateTextElement('ready-count', readyCount);
}

function updateDashboardWithOrder() {
    updateDashboard();
    updateSectionValues();
}

setInterval(updateDashboardWithOrder, 5000)

    }
    setInterval(() => {
        vehicles.forEach(vehicle => {
            vehicle.device = ['On', 'Check', 'Off'][Math.floor(Math.random() * 3)]; // Device ÏÉÅÌÉú Î≥ÄÍ≤Ω
        });
        updateDashboard(); // ÎåÄÏãúÎ≥¥Îìú ÏóÖÎç∞Ïù¥Ìä∏
    }, 10000);

    // **ÎåÄÏãúÎ≥¥Îìú ÌÜ†Í∏Ä Í∏∞Îä• Ï∂îÍ∞Ä**
    const dashboard = document.getElementById('dashboard');
    let isDashboardVisible = false;

    toggleButton.addEventListener('click', () => {
        if (isDashboardVisible) {
            dashboard.classList.add('hidden'); // ÎåÄÏãúÎ≥¥Îìú Ïà®ÍπÄ
            toggleButton.innerHTML = '¬´'; // Î≤ÑÌäº ÌëúÏãú Î≥ÄÍ≤Ω
        } else {
            dashboard.classList.remove('hidden'); // ÎåÄÏãúÎ≥¥Îìú Î≥¥ÏûÑ
            toggleButton.innerHTML = '¬ª'; // Î≤ÑÌäº ÌëúÏãú Î≥ÄÍ≤Ω
        }
        isDashboardVisible = !isDashboardVisible;
    });
});

